# 如何执行的传感器更新命令
对于`ASimModeBase`类，他应该需要调用`PawnSimApi::pawnTick(float dt)`来执行`PawnSimApi::update()`的操作。`PawnSimApi::update()`在不同的派生类中被重写，因此实际上执行的`update()`是子类的`update()`。
`PawnSimApi::pawnTick(float dt)`的实现形式是：
```cpp
    void PawnSimApi::pawnTick(float dt)
    {
        //default behavior is to call update every tick
        //for custom physics engine, this method should be overridden and update should be
        //called from every physics tick
        update();
        updateRenderedState(dt);
        updateRendering(dt);
    }
```
我发现，真正的

## 轮式车辆的传感器数据更新
轮式车辆所对应的`PawnSimApi`派生类是`CarPawnSimApi`，其`update()`的具体形式是
```cpp
//physics tick
void CarPawnSimApi::update()
{
    pawn_api_->update();

    PawnSimApi::update();
}
```
可见，它相当于执行了`pawn_api_->update()`，其代码为：
```cpp
void CarPawnApi::update()
{
    vehicle_api_->updateCarState(getCarState());
    vehicle_api_->update();
}
```
这一部分的`vehicle_api_->update();`就是在更新传感器的数据：
```cpp 
   // CarApiBase.cpp
    virtual void update() override
    {
        VehicleApiBase::update();

        getSensors().update();
    }
```
所以，`PawnSimApi::pawnTick(float dt)`的执行频率和传感器数据更新频率是一致的。而对于AirSim Unreal Plugin，其仅在一个地方被调用，即在`PawnSimApi::initialize()`中的末尾：
```cpp
    // PawnSimApi::initialize()

    params_.pawn_events->getPawnTickSignal().connect_member(this, &PawnSimApi::pawnTick);
```
而这个信号是由`void ACarPawn::Tick(float Delta)`所唯一发出：
```cpp
    void ACarPawn::Tick(float Delta)
    {
        Super::Tick(Delta);

        /*blah... .*/
        pawn_events_.getPawnTickSignal().emit(Delta);
    }
```
由于其Tick的定义是重写的，因此调用基类`AActor::Tick`的时候就会调用该函数`virtual void Tick(float Delta) override;`。在Unreal的官方文档中，对`AActor::Tick`的定义是：

> **Function called every frame on this Actor**. Override this function to implement custom logic to be executed every frame. Note that Tick is disabled by default, and you will need to check PrimaryActorTick.bCanEverTick is set to true to enable it.

也就是说，**这里的传感器更新的频率和帧更新频率是相同的**。这就会出现一个问题，就是帧与帧之间的时间是不同的，因此采样的间隔貌似也会不一样。

## 多电机无人机（四旋翼）的传感器数据更新
对于电机无人机`MultirotorPawnSimApi`，它直接重写了`PawnSimApi::pawnTick(float dt)`，然而里面却没有任何实现：
```cpp
    void MultirotorPawnSimApi::pawnTick(float dt)
    {
        unused(dt);
        //calls to update* are handled by physics engine and in SimModeWorldBase
    }
```
因此，对无人机来说，它就完全不会利用每一帧去更新它的状态和传感器数据。这里的注释说明了update()函数是通过physicEngine来实现的。

我们注意到，在与无人机有关的`ASimModeWorldBase`中(`AActor`的派生类，因此有Tick()函数)，有对`Tick(float dt)`的重写，其形式为：
```cpp
    void ASimModeWorldBase::Tick(float DeltaSeconds)
    {
        { //keep this lock as short as possible
            physics_world_->lock();

            physics_world_->enableStateReport(EnableReport);
            physics_world_->updateStateReport();

            for (auto& api : getApiProvider()->getVehicleSimApis())
                api->updateRenderedState(DeltaSeconds);

            physics_world_->unlock();
        }

        //perform any expensive rendering update outside of lock region
        for (auto& api : getApiProvider()->getVehicleSimApis())
            api->updateRendering(DeltaSeconds);

        Super::Tick(DeltaSeconds);
    }
```



对于电机无人机`MultirotorPawnSimApi`，它也重写了`PawnSimApi::update()`，但形式上有所不同：
```cpp
//this is high frequency physics tick, flier gets ticked at rendering frame rate
void MultirotorPawnSimApi::update()
{
    //environment update for current position
    PawnSimApi::update();

    //update forces on vertices
    multirotor_physics_body_->update();

    //update to controller must be done after kinematics have been updated by physics engine
}
```
而`MultiRotorPhysicsBody multirotor_physics_body_`派生自`PhysicsBody`类：
```cpp
//MultiRotorPhysicsBody
    virtual void update() override
    {
        //update forces on vertices that we will use next
        PhysicsBody::update();

        //Note that controller gets updated after kinematics gets updated in updateKinematics
        //otherwise sensors will have values from previous cycle causing lags which will appear
        //as crazy jerks whenever commands like velocity is issued
    }
```
它还有一个函数，应该是用来更新传感器数据：
```cpp
    //MultiRotorPhysicsBody
    //Physics engine calls this method to set next kinematics
    virtual void updateKinematics(const Kinematics::State& kinematics) override
    {
        PhysicsBody::updateKinematics(kinematics);

        updateSensors(*params_, getKinematics(), getEnvironment());

        //update controller which will update actuator control signal
        vehicle_api_->update();

        //transfer new input values from controller to rotors
        for (uint rotor_index = 0; rotor_index < rotors_.size(); ++rotor_index) {
            rotors_.at(rotor_index).setControlSignal(
                vehicle_api_->getActuation(rotor_index));
        }
    }
```
这里面的`updateSensors(*params_, getKinematics(), getEnvironment());`就是更新传感器数据的地方。
而`PhysicsBody::update()`是这样的
```cpp
 
    virtual void update() override
    {
        UpdatableObject::update();

        //update individual vertices - each vertex takes control signal as input and
        //produces force and thrust as output
        for (uint vertex_index = 0; vertex_index < wrenchVertexCount(); ++vertex_index) {
            getWrenchVertex(vertex_index).update();
        }
        for (uint vertex_index = 0; vertex_index < dragVertexCount(); ++vertex_index) {
            getDragVertex(vertex_index).update();
        }
    }
```
貌似没有更新任何的传感器数据之类的。
