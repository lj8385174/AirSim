# 如何执行的传感器更新命令
对于`ASimModeBase`类，他应该需要调用`PawnSimApi::pawnTick(float dt)`来执行`PawnSimApi::update()`的操作。`PawnSimApi::update()`在不同的派生类中被重写，因此实际上执行的`update()`是子类的`update()`。
`PawnSimApi::pawnTick(float dt)`的实现形式是：
```cpp
    void PawnSimApi::pawnTick(float dt)
    {
        //default behavior is to call update every tick
        //for custom physics engine, this method should be overridden and update should be
        //called from every physics tick
        update();
        updateRenderedState(dt);
        updateRendering(dt);
    }
```
我发现，真正的

## 轮式车辆的传感器数据更新
轮式车辆所对应的`PawnSimApi`派生类是`CarPawnSimApi`，其`update()`的具体形式是
```cpp
//physics tick
void CarPawnSimApi::update()
{
    pawn_api_->update();

    PawnSimApi::update();
}
```
可见，它相当于执行了`pawn_api_->update()`，其代码为：
```cpp
void CarPawnApi::update()
{
    vehicle_api_->updateCarState(getCarState());
    vehicle_api_->update();
}
```
这一部分的`vehicle_api_->update();`就是在更新传感器的数据：
```cpp 
   // CarApiBase.cpp
    virtual void update() override
    {
        VehicleApiBase::update();

        getSensors().update();
    }
```
所以，`PawnSimApi::pawnTick(float dt)`的执行频率和传感器数据更新频率是一致的。而对于AirSim Unreal Plugin，其仅在一个地方被调用，即在`PawnSimApi::initialize()`中的末尾：
```cpp
    // PawnSimApi::initialize()

    params_.pawn_events->getPawnTickSignal().connect_member(this, &PawnSimApi::pawnTick);
```
而这个信号是由`void ACarPawn::Tick(float Delta)`所唯一发出：
```cpp
    void ACarPawn::Tick(float Delta)
    {
        Super::Tick(Delta);

        /*blah... .*/
        pawn_events_.getPawnTickSignal().emit(Delta);
    }
```
由于其Tick的定义是重写的，因此调用基类`AActor::Tick`的时候就会调用该函数`virtual void Tick(float Delta) override;`。在Unreal的官方文档中，对`AActor::Tick`的定义是：

> **Function called every frame on this Actor**. Override this function to implement custom logic to be executed every frame. Note that Tick is disabled by default, and you will need to check PrimaryActorTick.bCanEverTick is set to true to enable it.

也就是说，**这里的传感器更新的频率和帧更新频率是相同的**。这就会出现一个问题，就是帧与帧之间的时间是不同的，因此采样的间隔貌似也会不一样。

## 多电机无人机（四旋翼）的传感器数据更新
对于电机无人机`MultirotorPawnSimApi`，它直接重写了`PawnSimApi::pawnTick(float dt)`，然而里面却没有任何实现：
```cpp
    void MultirotorPawnSimApi::pawnTick(float dt)
    {
        unused(dt);
        //calls to update* are handled by physics engine and in SimModeWorldBase
    }
```
因此，对无人机来说，它就完全不会利用每一帧去更新它的状态和传感器数据。这里的注释说明了`update()`函数是通过`physicEngine`来实现的。

那么，`physicEngine`的`update()`究竟是如何调用到去更新传感器数据的呢？下面这张图可以帮助进行解释：

![image-20200630142518340](C:\Users\mfary\AppData\Roaming\Typora\typora-user-images\image-20200630142518340.png)

可以看出，这些与物理模型有关的资源本质上都是使用`PhysicsWorld`来进行管理的。它管理着`World`类就包含了一个`PhysicsEngineBase`。在这个`PhysicsEngineBase`里面，拥有者所有带有物理引擎的物理实体`PhysicsBody`。对于目前版本的AirSim，带有物理引擎的对象就是四旋翼。在AirSim启动后，`PhysicsWorld`会对所有资源进行初始化，然后会调用`World.SheduledExcutor`组件，开启一个线程，周期性地执行`World::worldUpdatorAsync()`，而这个函数会最终调用`PhysicsBody::updateKinematics()`。对于四旋翼，会调用其`updateSensors()`函数，对所有的传感器数据进行更新。

从这个流程来看，AirSim为我们提供了一个完整的框架。如果需要添加不同的物理实体，仅需添加不一样的`PhysicsBody`就行了，即便是使用车辆也是如此。

另外一个特点是，在`PhysicsEngine::update()`中，会对所有的物理实体进行更新，因此实现了所有物理实体状态的同步更新。如果有需要同时更新的测量，可以在这里得到统一的更新。

## 物理引擎驱动和非物理引擎驱动的实体之间的数据交换

从上面对不同实体的分析看出，两个不同实体更新传感器数据的策略是不同的。在目前看来，要想直接通过编程的方法来实现两者的统一