# 如何执行的传感器更新命令
对于`ASimModeBase`类，他应该需要调用`PawnSimApi::pawnTick(float dt)`来执行`PawnSimApi::update()`的操作。`PawnSimApi::update()`在不同的派生类中被重写，因此实际上执行的`update()`是子类的`update()`。

## 轮式车辆的传感器数据更新
轮式车辆所对应的`PawnSimApi`派生类是`CarPawnSimApi`，其`update()`的具体形式是
```cpp
//physics tick
void CarPawnSimApi::update()
{
    pawn_api_->update();

    PawnSimApi::update();
}
```
可见，它相当于执行了`pawn_api_->update()`，其代码为：
```cpp
void CarPawnApi::update()
{
    vehicle_api_->updateCarState(getCarState());
    vehicle_api_->update();
}
```
这一部分的`vehicle_api_->update();`就是在更新传感器的数据：
```cpp 
   // CarApiBase.cpp
    virtual void update() override
    {
        VehicleApiBase::update();

        getSensors().update();
    }
```
所以，`PawnSimApi::pawnTick(float dt)`的执行频率和传感器数据更新频率是一致的。而对于AirSim Unreal Plugin，其仅在一个地方被调用，即在`PawnSimApi::initialize()`中的末尾：
```cpp
    // PawnSimApi::initialize()

    params_.pawn_events->getPawnTickSignal().connect_member(this, &PawnSimApi::pawnTick);
```
而这个信号是由`void ACarPawn::Tick(float Delta)`所唯一发出：
```cpp
    void ACarPawn::Tick(float Delta)
    {
        Super::Tick(Delta);

        /*blah... .*/
        pawn_events_.getPawnTickSignal().emit(Delta);
    }
```
由于其Tick的定义是重写的，因此调用基类`AActor::Tick`的时候就会调用该函数`virtual void Tick(float Delta) override;`。在Unreal的官方文档中，对`AActor::Tick`的定义是：

> **Function called every frame on this Actor**. Override this function to implement custom logic to be executed every frame. Note that Tick is disabled by default, and you will need to check PrimaryActorTick.bCanEverTick is set to true to enable it.

也就是说，**这里的传感器更新的频率和帧更新频率是相同的**。这就会出现一个问题，就是帧与帧之间的时间是不同的，因此采样的间隔貌似也会不一样。